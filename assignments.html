

1. Create Login Action
2. Expect to receive form data to login action
3. Send a POST request to '/api/v1/users/login' -> this.$axios.$post()
4. In case of success expect to recieve "user" object in "then" block
5. Bonus: In case of error "catch" error and return Promise.reject(error)
6. Create a mutation to set user to a state
7. Dispatch login action when clicking login button and debug this functionality to make sure you are setting user to a state



1. Create logout Action
2. send a POST request to '/api/v1/users/logout'
3. in case of success in "then" commit mutation "setAuthUser" and set it to a null
4. you can return also "true" in case of success
5. In case of error return Promise.reject with error
6. create logout function in Navbar component
7. dispatch logout action when clicking logout button
8. in case of success dispatch, navigate user to login page


1. Create "register" action
2. expect to receive register form data to an action
3. send a POST request to "/api/v1/users/register" with register form data
4. You don't need to handle "then" block in action just handle "catch" where
you will return Promise.reject with error
5. in register page create function "register" and dispatch register action with
register form data
6. In case of success redirect user to login page
7. in case of error display toast message with an error
8. on register button click call function register
9. Test your functionality, register an user and login after
NOTE: provide all data during registration, also an valid avatar url because
you can get an error in navbar since avatar would be undefined
GOOD LUCK (:



1. Create "guest" middleware
2. check if user is authenticated
3. if user is authenticated then redirect to home page
4. apply this middleware to login and register page


1. Create new action "fetchInstructorCourses" where you will send "get" request to '/api/v1/products/user-products'
2. in "then" block you will receive "courses" data, please commit them to the state. In "catch" block reject promise
3. create mutation "setCourses" where you will assign courses to the state
4. in instructor/courses/index.vue create "fetch" function and dispatch "fetchInstructorCourses" action. You action is in "instructor/course/...."
5. in instructor/courses/index.vue create computed properties and get instructor courses
6. verify your functionality by debugging or Vue extension


1. Separate create form into 2 components - CourseCreateStep1, CourseCreateStep2
2. Provide component to create form


1. In CourseCreateStep2 get categories from store
2. Display categories options with v-for
Note: don't forget :key,


1. Create action "createCourse" in instructor/course.js and expect to receive form data
2. send a POST request to '/api/v1/products' with courseData
3. In instructor create page dispatch "createCourse" with form data after user will click on "Confirm" button
4. in "then" block redirect user to "/instructor/courses" page



1. Create functionality to display one component at the time
2. use "component" and "keep-alive" element from vue as we did in "create" page
Note: Implement: "activeStep", and "steps" and method to display component depending on clicked "menu"



1. create "fetchCourseById" action in instructor/course.js
2. send a GET request to '/api/v1/products/:id' and expect to receive course id in arguments of this action
   ":id" is dynamic part, you need to provide id of the course
3. in "then" block expect to receive "course"
4. commit mutation "setCourse"
5. in mutation assign to state.item received course
6. in manage.vue dispatch "fetchCourseById" in "fetch". Don't forget to provide course id to this dispatch call. You can get course id from "params"
7. in computed of manage.vue "mapState" and get course from store
8. verify you are getting your course in "Vue" extenstion



1. in instructor/course.js create action "updateCourse"
2. send a PATCH request to '/api/v1/products/:id' and don't forget to send a course data
NOTE: you can get course data from "state.item" in action
3. in "then" block receive "course" and call mutation "setCourse"
4. in "catch" block reject promise
5. dispatch this action in manage page when clicking on "save" button
6. on success display $toasted  success message with your custom text
7. in case of an error display $toasted message with an error
8. Test your functionality. Update some data of the course , click save and refresh page. See if data were perssisted.



1. in instructor/blog.js create action "fetchBlogById"
2. make a GET request to "/api/v1/blogs/:id"
3. in "then" block expect to receive "blog", commit this "blog" to the state
4. in /_id/edit.vue in "fetch" dispatch "fetchBlogById"
5. Try this functionality. Create new blog. After you will be redirect to edit page verify you have blog in store


1. send a PATCH request to "/api/v1/blogs/${id}" with data of blog
2. in "then" commit "setBlog"
3. dispatch action in saveBlog


1. create action "fetchBlogBySlug"
2. dispatch this action in _slug.vue and provide slug from params
3. in "fetchBlogBySlug" send GET request to '/api/v1/blogs/s/:slug'
4. expect to receive "blog" and commit it to the state under "item"
5. in slug page get blog in computed properties
6. display blog content somewhere in template












